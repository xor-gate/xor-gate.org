Introduction to Golang
As an alternative to C & C++
8 Oct 2019
Tags: golang, c, c++

[[https://xor-gate.org][Jerry Jacobs]]
Software Engineer, [[https://heliox.nl][Heliox]]
jerry.jacobs@heliox.nl

* Welcome!

.image introduction-to-golang/golang-logo.png
.image introduction-to-golang/golang-mascot.jpg

* Introducing myself

- Installed [[https://en.wikipedia.org/wiki/Ubuntu_version_history#Ubuntu_5.10_(Breezy_Badger)][Ubuntu 5.10 long time ago]]
- Open-source enthousiast for +14 years
- Highly-experienced with UNIX-like environments
- Programming C and other languages for +10 years
- Big love for Embedded Systems
- Deployed Go in production systems for 2.5 years (Custom IoT Cloud Platform)

* Agenda

- History
- Introduction of the language
- Pros and cons compared to C/C++
- Deep dive
- Workshop with Q&A

* History

Between 2007 and 2012

- Project starts at Google in 2007 (by Griesemer, Pike, Thompson)
- Open source release in November 2009 ([[https://www.youtube.com/watch?v=rKnDgT73v8s][youtube]]/[[https://talks.golang.org/2009/go_talk-20091030.pdf][slides]])
- More than 250 contributors join the project
- Version 1.0 release in March 2012

2018 and beyond

- [[https://blog.golang.org/go2-here-we-come][Go 2 announced]] in November 2018
- Version 1.13 release in September 2019 
- Solved the dependency management problem after many years

* Construction speed

- It takes too long to build software (minutes to hours)
- The tools are slow and are getting slower
- Dependencies are uncontrolled
- Machines have stopped getting faster
- Yet software still grows and grows
- If we stay as we are, before long software construction will be unbearably slow

* Why a new language?

- These problems are endemic and linguistic.
- New libraries wonâ€™t help (C++14/17 etcetera).
- Adding anything is going in the wrong direction.
- Need to start over, thinking about the way programs are written and constructed.

* Language goals

- The efficiency of a statically-typed compiled language with the ease of programming of a dynamic language
- Safety: type-safe and memory-safe
- Good support for concurrency and communication
- Efficient, latency-free garbage collection
- High-speed compilation

* Language features

- [[https://www.youtube.com/watch?v=rFejpH_tAHM][Simple language]], easy to read and easy to write: [[https://talks.golang.org/2015/simplicity-is-complicated.slide][Simplicity!]].
- [[https://en.wikipedia.org/wiki/Type_system#Static_type_checking][Staticly typed]] and staticly compiled (no "slow" [[https://en.wikipedia.org/wiki/Virtual_machine][VM]], like Java or Python)
- [[https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)][Garbage collected]]
- Cross-compile is easy: [[https://github.com/golang/go/wiki/GoArm][GOARCH=arm GOOS=linux]]
- No undefined behaviours (compared to C/C++)
- Open Source

* Modern programming practices

The language and toolchain contains support for modern programming practices

- Documentation ([[https://golang.org/pkg/cmd/go/internal/doc/][go doc]])
- Unit testing ([[https://golang.org/pkg/cmd/go/internal/test/][go test]])
- Performance benchmarking ([[https://golang.org/pkg/cmd/go/internal/test/][go test -bench]])
- [[https://en.wikipedia.org/wiki/Race_condition][Race condition]] testing ([[https://golang.org/pkg/cmd/go/internal/test/][go test -race]])
- Code generation ([[https://golang.org/pkg/cmd/go/internal/generate/][go generate]])

* Hello World!

.code introduction-to-golang/hello.go

Run the program:

  $ go run hello.go

* Pros and cons compared to C/C++


*Pros*

- Modern simple language
- Simple tooling
- No undefined behaviour in [https://golang.org/ref/spec][the specification]

*Cons*

- Not designed for deep embedded systems (needs an OS)
- Runtime runs only on latest supported OS
- Language not standarized (like C11 has ISO/IEC 9899:2011)

* Pros and cons of tooling


* C/C++ is just a language specification, needs many tools and scripts

- Compiler toolchain, e.g GCC or clang (LLVM)
- Documentation generator (Doxygen)
- Code coverage tool, e.g gcov or lcov
- Build and dependency system <- This is where the real pain is

- Go has just a single tool
- Yeah just `go <whatever>`

* The Go approach to Dependencies

Construction speed depends on managing
dependencies. Explicit dependencies in source allow:
- fast compilation
- fast linking

The Go compiler pulls transitive dependency type
info from the object file - but only what it needs.

If A.go depends on B.go depends on C.go:
- compile C.go, B.go, then A.go.
- to compile A.go, compiler reads B.o not C.o.

At scale, this can be a huge speedup.

* The Go approach to Concurrency

- Go provides a way to write systems and servers
as concurrent, garbage-collected processes
(goroutines) with support from the language and
run-time
- Language takes care of goroutine management,
memory management
- Growing stacks, multiplexing of goroutines onto
threads is done automatically
- Concurrency is hard without garbage collection
- Garbage collection is hard without the right
language

* Golang for embedded systems/microcontrollers?

As Go is not original designed for microcontrollers. There are some efforts to run it on AVR and ARM.

- https://tinygo.org
- https://gobot.io/
- https://embd.kidoman.io
- https://github.com/ziutek/emgo?

* Quicklinks

- [[https://try.golang.org][try.golang.org]]
- [[https://blog.golang.org][blog.golang.org]]
- [[https://github.com/avelino/awesome-go][github.com/avelino/awesome-go]]
- [[https://www.golang-book.com/books/intro][An Introduction to Programming in Go]]
- [[https://youtube.com/c/justforfunc][JustForFunc: Programming in Go]]
